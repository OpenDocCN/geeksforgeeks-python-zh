# 迭代器和生成器的区别

> 原文:[https://www . geeksforgeeks . org/迭代器与生成器之差/](https://www.geeksforgeeks.org/difference-between-iterator-vs-generator/)

通过应用相同的逻辑重复一次以上的过程称为迭代。在像 python 这样的编程语言中，创建循环时几乎没有条件执行迭代，直到超出极限。如果循环连续执行 6 次，那么我们可以说这个特定的块已经迭代了 6 次。

**示例:**

## 蟒蛇 3

```
a = [0, 5, 10, 15, 20]
for i in a:
    if i % 2 == 0:
        print(str(i)+' is an Even Number')
    else:
        print(str(i)+' is an Odd Number')
```

**输出:**

> 0 是偶数
> 
> 5 是奇数
> 
> 10 是偶数
> 
> 15 是一个奇数
> 
> 20 是偶数

### **迭代器**

迭代器是一个包含可数数值的对象，用于迭代列表、元组、集合等可迭代对象。迭代器是用一个类实现的，这里不需要一个局部变量来进行迭代，它遵循延迟求值，表达式的求值将被暂停并存储在内存中，直到该项被特别调用，这有助于我们避免重复求值。由于实现了惰性评估，它只需要 1 个内存位置来处理值，当我们使用一个大数据集时，内存空间的浪费将会减少，同时加载整个数据集的需求将不会存在。

使用迭代器-

*   **iter()** 关键字用于创建包含可迭代对象的迭代器。
*   **next(** )关键字用于调用 iterable 对象中的下一个元素。
*   可迭代对象完成后，要再次使用它们，请将它们重新分配给同一个对象。

**示例:**

## 蟒蛇 3

```
iter_list = iter(['Geeks', 'For', 'Geeks'])
print(next(iter_list))
print(next(iter_list))
print(next(iter_list))
```

**输出:**

> 奇葩
> 
> 为
> 
> 奇葩

### **发电机**

这是以简单的方式创建迭代器的另一种方式，它使用关键字“yield”，而不是在定义的函数中返回它。生成器是使用函数实现的。正如迭代器一样，生成器也遵循惰性评估。这里，yield 函数返回数据，而不影响或退出该函数。它将返回一个可迭代格式的数据序列，我们需要迭代序列来使用数据，因为它们不会将整个序列存储在内存中。

**示例:**

## 蟒蛇 3

```
def sq_numbers(n):
    for i in range(1, n+1):
        yield i*i

a = sq_numbers(3)

print("The square of numbers 1,2,3 are : ")
print(next(a))
print(next(a))
print(next(a))
```

**输出:**

> 数字 1、2、3 的平方是:
> 
> one
> 
> four
> 
> nine

## 迭代器和生成器的区别表

<figure class="table">

| 迭代程序 | 发电机 |
| --- | --- |
| 类用于实现迭代器 | 函数用于实现生成器。 |
| 这里不使用局部变量。 | 存储产量函数之前的所有局部变量。 |
| 迭代器主要用于使用 iter()函数迭代其他对象或将其他对象转换为迭代器。 | 生成器主要用于循环中，通过返回循环中的所有值来生成迭代器，而不影响循环的迭代 |
| 迭代器使用 iter()和 next()函数 | 生成器使用 yield 关键字 |
| 每个迭代器不是一个生成器 | 每个生成器都是一个迭代器 |

</figure>